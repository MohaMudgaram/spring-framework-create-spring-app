Course Overview
Course Overview
Hello, my name is Dan Bunker, and welcome to my course, Creating your First Spring Boot Application. I've been building software applications and doing software consulting for many years now in the Salt Lake City area. Many of the applications that I have built have used Spring Boot. Why do I use this framework? Well, that is easy to answer. Spring Boot makes building quality Java applications fast and easy. In this course, we're going to learn exactly what Spring Boot is and why you might want to use it on your next project. Some of the major topics and exercises that we will cover include containerless architectures, customizing and configuring Spring Boot, deploying Spring Boot in production environments, and finally, we'll be building a Spring Boot app from scratch. By the end of this course, you'll know exactly how to create and work with a Spring Boot app, which will give you the ability to utilize this framework on your own on your own real-world project. Before beginning the course, you should be familiar with just some basic Java, the Maven build tool, and web application fundamentals such as endpoints, REST, and relational databases. From here, you should feel comfortable diving into the Spring framework with courses on Core Spring, Spring MVC, and Spring Data JPA. I hope you join me on this journey to learn Spring Boot with the Creating Your First Spring Boot Application, course at Pluralsight.
Using Spring Boot to Create Applications
Version Check
Introduction
Spring is quite a large framework. There are many integrations, libraries, and options. And if you're sitting down to learn Spring, it can be intimidating and difficult to know just where to start. If you're watching this course, then you've picked the absolute best place to start learning Spring, and that's with the Spring Boot framework. My name is Dan Bunker, and I've been building Java applications for over 20 years. Spring Boot takes a lot of the complexity of building enterprise-based Spring applications and makes it easy to get everything wired up and running in just a few minutes. Before we do that, you're going to need a couple of items on your computer. You'll need to have Java installed, and you can obtain this from Oracle, and we'll be using at least Java version 12. Once you have a Java JDK installed, we'll be doing all of our coding in IntelliJ. There are other IDEs you're welcome to use, but all the examples and demos will be in IntelliJ in this course. If you go to the IntelliJ home page, you can click on the Download area and choose the particular download that you want. For this course, I'll be using the community version of this, which is the free version of IntelliJ. And that's pretty much it for the tools. Next, we'll talk about exactly what Spring Boot is, and then we'll get started on building an application from scratch.
What Is Spring Boot?
Spring Boot has been a game changer for the Java platform. Before Spring Boot came around, it wasn't uncommon for a developer to spend a few days wiring an MVC framework to a persistence framework and getting that talking to a database. Did you catch that? Days to get the app propped up before any real coding can take place. Spring Boot takes an opinionated view on how a Spring app should be constructed. By doing so, you can now stand up a fully-wired application from controller to database in just a matter of seconds. Spring Boot prefers Spring frameworks, like Spring MVC and Spring Data, which is one way it makes it opinionated, but this also serves another purpose. Spring Boot makes building applications very quick, quick like Ruby on Rails, and Django, and Python quick. Finally, Spring Boot got away from container dependence and really wants applications to be standalone Java apps. This makes a lot of sense for cloud deployments. Instead of deploying a WAR file to a Tomcat container, for example, Spring Boot embeds Tomcat inside of the app and produces a self-contained JAR file that can be run on its own using the Java command. As fun as it might be to talk about how awesome Spring Boot is, I know that you're really here to code and get your hands dirty with Spring Boot, so let's go ahead and get started.
Demo: Creating a Spring Boot App with Spring Initializr
Spring has made creating a new Spring Boot project easier than ever. I'll be covering a couple of different ways of generating or creating a project from scratch. We'll begin first by using the site Spring Initializr, which you can go to at a URL, start.spring .io, in your browser. Get that open and follow along. We're going to be building a conference scheduling app in this course, and this app will hold difference sessions and allow speakers to be assigned as the presenter of a session. The speaker can present more than one session. If you been to any conference, think of this as the planning and organization app that builds out the conference topics and sessions for the organizers. So to begin, any app that you create will need a few customizations, and this app will be no exception. First off, we're going to be using the Maven Project type for the project rather than Gradle, next, we're going to use the preselected Java language, and we'll go ahead and select the latest Spring Boot version, which at the time of this recording is 2.1 .9. For the Group name, I'm going to go ahead and change that to say com.pluralsight, and I'm going to change the Artifact name to be conference-demo. Finally, we need to tell the project generator which pieces of Spring we'd like to include in our Spring Boot application. To keep this simple, I'm just going to select the Spring web dependency. You can do that by switching tabs from the magnifying glass to the table layout. And in here, you can see all of the different frameworks that are available for your application. All I want to do is begin by using the Spring Web, so I'm going to select that. Now if I go back to the magnifying glass, you'll see that the Selected dependencies is simply Spring Web. If you want, you could also type them in here on this text box, and you could find different project or libraries that way as well. Spring Web is going to pull in Spring MVC and some REST API information, which we'll need in our application. At this point, we're now able to generate the project. So down at the bottom, we could go ahead and click on the Generate button. That will download your project as a ZIP file to your computer, and that's it! We have a new Spring Boot project. If you want to know how to import it into your IntelliJ IDE so you can start coding with it, that's what's coming up next.
Demo: Importing and Setting up a Spring Boot App
As I mentioned previously, I'll be using IntelliJ for my main IDE for this course. If you're familiar with something else, like Eclipse or a Spring Tool suite, feel free to use that, but all the demos I'll be doing will be with IntelliJ. In the previous clip, we generated a new Spring Boot application, and that downloaded a ZIP file to our hard drive. So you need to locate where that ZIP file was and go ahead and extract it. Next, go ahead and open up IntelliJ, and the IDE will present you with a few options to get a project up and running. Since we already have our project, I'm simply going to click the Import Project button and find the file we just extracted. Go ahead and select the extracted folder and Click OK. Next, IntelliJ asks what type of project that I'm working with. I chose Maven on the project creation on the Spring initializer site, so I'm simply going to select Maven and click Next. This screen allows for some customization, but I'm going to go ahead and just leave the default recommended settings and click Next again. At this point, IntelliJ has found my project. I can leave the default selected conference-demo checked and click Next. In this dialog, you can choose or set up your JDK that you want to use for the project. Assuming you have a JDK installed, it should find one, and I'm going to go ahead and use the JDK 12 and click Next. Finally, if you want to adjust the project name, you can, but I'm going to go ahead and leave the recommended default here, and finally, click Finish. After a few seconds, IntelliJ should successfully import your conference app, and you should be ready to start working with it. Next up, I'm going to take a moment and go over the layout of the Spring Boot application and the different pieces that were set up from the initializer, as well as set up a few of my own best practice pieces in the application.
Demo: Overview of a Spring Boot App
When you're working with Maven, all Maven-based apps are pretty much laid out the same way. To add a little bit more room, I'm simply going to toggle down this bottom pane by clicking on the Build button, and I'm going to expand open the project editor. If you open up the conference-demo portion of your project editor, this is where all of the contents that were generated by the Spring initializer live. The firs important file worth noting is probably the pom.xml. This is a Maven structure, and this is where all of the dependencies live inside of your application. And in fact, you can see that the spring-boot-starter-web was added to this, which was the Spring Web dependency we checked in the Spring Initializr website. We'll be covering the POM file and dependencies in more depth a little later on. The next important section worth digging into is the source code of the app, and that is contained in the src folder. It even lays out a main and test folder, and each of these folders correspond to code that will be either for testing purposes or for the application. Diving deeper into the main folder, you can see that there is Java source code and resources source code. Property files, XML files, and any other non-Java-based file will go into the resource area, and all Java code will go into the Java folder. Underneath Java, you'll notice that the package structure is set up based off of the info entered on the Spring initializer in the group and package section. So for this app, the package name is com.pluralsight .conferencedemo, and I can open that up, and I have a basic Java file called ConferenceDemoApplication here. And if I open up the ConferenceDemoApplication, this is the main entry point for your Spring Boot application. There are a few interesting pieces in this file that I want you to take notice of. First is the public void main method. That method is the main entry point into any Java application, and it's just a plain Java way to start your application, and that's how your program will begin its life, and this is also how your program can be run standalone rather than deployed to a container. You'll also notice that there is an annotation in this class called @SpringBootApplication. This tells the Spring Boot loader to run the application as a Spring Boot app and configure it like a Spring Boot app. At this point, you might be asking, where is the rest of the code, and where do I start writing code? So far, the app has just a couple lines of Java code, and this gives you an idea of how powerful Spring Boot is. You could run the application with just this small amount of code, and the app would fire up and run. Granted, it won't do anything interesting yet because we haven't added any interesting code to it. One of the first things that I like to do is to get the app set up and sectioned out into its architectural pieces. I'm going to do that by adding some new packages. I'm going to select the com.pluralsight .conferencedemo package, right-click on it, and say New, Package. And I'm first going to create a controllers package that will hold our API controllers. I'm going to create another new package, and this one, I'm going to call models. This will hold our JPA entities and other persistence info. The third package I'm going to create is called repositories. This will hold our JPA repositories. And finally, I'm going to create one last package called services. This package could hold service or logic-based code that may need to go into the application. These packages aren't necessary for your application, but I find that creating some best practices with a little organization like this early on really helps keep the code in the application from getting messy later on. And that's it for the basic layout. If you've done any kind of MVC app before and you've used Maven, this layout shouldn't be too surprising for you.
Demo: Creating a Spring Boot App with IntelliJ
For this next clip, I'm going to show you an alternative way to create a Spring Boot application. If you aren't interested in this or you don't have a licensed version of IntelliJ, you can go ahead and skip ahead to the next clip. If you do happen to have an IntelliJ Ultimate edition and a paid license, you can also easily create a Spring Boot project right from the IDE. This time, instead of importing the project, we're just going to go ahead and create a new project by clicking on that button. On the left-hand-side menu, find the Spring Initializr item and click on it and then select your Project SDK version. I'm simply going to use the default recommendation of version 12 and then click Next. At this point, IntelliJ has communicated with the Spring Initializr site, and it wraps it in a nice IntelliJ dialog. I can now set up the group and artifact IDs, select my Maven, pom.xml, and Java version. So I'll go ahead and customize those quickly. I've set the Group to com.pluralsight and the artifact to conference-demo. I'll leave it as a Maven project with the Java language, and I'm going to bump up the Java version to something a little newer. And when I'm happy with my settings, I'll go ahead and click Next. At this point, I can select my dependencies and integrations that I want to bring into my Spring Boot project, and I want to use the Web, so I'll select that and click Next. I'll leave the Project name and Project location as is and just click Finish. IntelliJ will go ahead and download from the Spring Initializr site and pull that into the app, and you're ready to get started. I'm going to simply just rearrange some things, close the Maven dialog, open up the Project tab, and this should look pretty much exactly like the community edition at this point. There's one other way that you can work with Spring Boot that's a little different than any type of Java development that you might have done before. Coming up next, we'll take a look at the Spring Boot CLI, command line interface.
Demo: Using the Spring Boot CLI
If you've ever used a command-line tool like Heroku's CLI or used Ruby on Rails with its command-line tools, the Spring Boot CLI is very similar. If you aren't a power user and don't use the command line much, don't worry. You don't have to give the CLI a try. You will, however, be surprised what you can do without ever leaving your shell or terminal. There are a couple ways of installing Spring Boot CLI, and you can check out the installation options here at the Spring Boot documentation URL. You can do a manual installation, or an SDKMAN, or a Homebrew if you're on the macOS to get stuff installed. At this time, I prefer the SDKMAN way, and you can install SDKMAN at sdkman.io, and this tool is like RVM for Ruby or NVM for Node. And once you have the SDK installed, you simply need to open a new terminal or shell. Once you have SDKMAN installed, you can easily install Spring Boot by typing sdk install springboot. SDKMAN will install the latest version of Spring Boot. And once that is completed, you can then type spring at the command line to start using Spring Boot in a more interactive mode type of way. If you type spring without providing any particular subcommand, it'll just show some help. You can also type spring help to give you additional options to run with this tool. One of the commands that you might be interested in is spring init, and this is yet another way that you can create a Spring Boot project. You can also run groovy-based Spring Boot application from the command line using spring run. Since this course is focused on Java and Spring Boot, I'm not going to go too in depth with the groovy, but there are some pretty cool things that you can do in this space. If you like the terminal and you're comfortable with it, you'll probably like the Spring Boot command-line install tools, and you should go back to the documentation to find out more information.
Understanding Spring Boot Starters
Before we jump into full app building mode in the next section, I want to emphasize how amazing this Spring Boot starter concept is. The starters are what really makes Spring Boot shine. First, a starter is a way to integrate a dependency on your project to get it all set up and ready to run by simply declaring it as a dependency. Did you catch that? Declare a starter, and you're done. All Spring-based apps need to specify what pieces of the Spring framework they're going to utilize. If you have a really complex app, you will also have a lot of dependencies, and those dependencies will have dependencies, and so on. This makes version mismatches and other headaches appear. Spring Boot starters solve those headaches by allowing you to simply declare the starter, and it will take care of getting all of the right dependencies and versions in place. Let's quickly take a look at what this looks like in the application that we just created. All dependencies in Maven-based Spring projects are kept in the pom.xml file. That's at the root of the project, so I'm going to go ahead and double-click and open it up. If you jump to the dependencies section of the file, you can see that we have the starter-web and the starter-test defined. These starters set up Spring MVC and the Spring test frameworks respectively. To get a better idea of exactly what each dependency does, you can expand the Maven slider on the right-hand of the IDE. Click on the app and then open the dependency section of the tree. When I expand the spring-boot-starter-web, you should take notice of two things. First, there is a handful of dependencies that this starter brought in. All of these dependencies are necessary to make Spring MVC work correctly. And second, each sub dependency has a specific version. The Spring developers have spent a lot of time getting these versions to all match up so that they work together out of the box without any problems. I'm going to go ahead and close the Maven tab and jump back to the pom.xml file. You'll notice that when you declare a starter dependency, you don't have to specify a version. So how does Spring Boot know which versions to add to your project? The answer lies at the top of the file in the spring-boot-starter-parent declaration. You can see we have a specific Spring Boot version declared here. The starter-parent declares the version of all the possible integrations that work with this version of Spring Boot. This is sometimes referred to the BOM, or bill of materials. You can see Spring Boot's bill of materials for your project by right-clicking on the pom.xml file and drill into the Maven sub menu and click Show Effective POM. This command essentially flattens out the parent contents with the POM contents. As you browse through this, you can see all of the frameworks that Spring has integrated and brought in. This is why Spring Boot is so awesome is that you no longer need to spend time doing this because it's already done for you. That's pretty much it for this section of the course. Coming up next, I'll quickly summarize everything that was covered.
Summary
Hopefully at this point, you've seen how easy it is to create Spring Boot app and how powerful it is at getting frameworks integrated and set up quickly. Here's what you should have gotten out of this module. First, you should be able to answer the question, what is Spring Boot? It's simply an opinionated rapid application development framework. Next, we covered a few ways that you can create a new Spring Boot application. You can use the Spring Initializr site, the IntelliJ IDE, or the command-line interface tools. In the end, each way ends up with the same thing, a ready to go Spring Boot application that you can start working with. Finally, we covered the Spring Boot starters and how they magically get libraries and frameworks wired up, integrated, and ready to go. Most of the magic is provided by the spring-boot-starter-parent. And that's it for this section. Coming up next, we're going to switch into full-time development mode and get this conference scheduling API built and running.
Building Apps with Spring Boot
Introduction
We now have a basic Spring Boot app created, and we're ready to actually do something with it. After all, the whole point of learning Spring Boot is to be able to build an application. In this section, that's exactly what we're going to do. I briefly mentioned that we'll be building a conference scheduling app. This app will include Spring MVC, Spring Data JPA, JPA, and a relational database, which will be Postgres, pretty much a full stack Spring API micro service app. We won't be fussing around with any UI in this course, so we can focus solely on the Spring Boot and Spring components. Coming up next, I'm going to cover the app in a little more detail about what we'll be building.
Application Overview
Let's take a moment and look at the Pluralsight LIVE conference site to get an idea of some of the concepts that we'll be coding up. This was the agenda for the 2019 Pluralsight LIVE conference held in Salt Lake City. Towards the top, there is a general overview of the agenda with the schedule. And as you scroll down, it takes us to the Breakout sessions. These sessions are essentially what we'll be creating. We'll have some data structures and endpoints around sessions and speakers for a conference. An example of a session would be LESSONS LEARNED BUILDING A GLOBAL TECHNOLOGY ORGANIZATION. Sessions obviously have speakers or presenters associated with it, and in this case, you can see that there are two presenters, Shawn Malhotra and Thomson Reuters. If you expand the session title, you can also see a summary of the session. The topic in the description will be also something that we'll include in our application. There are a lot of other things like session tags and the session schedules which we won't be building simply due to time, but that will give you something to work on on your own. The more practice you have building and working with Spring Boot and Spring, the better you'll get. So now that we have a basic general idea of what we'll be building, let's go ahead and get started.
Setting up the Database
The foundation for any good well-built application begins with the data and the database layout. So to speed things up, I'm providing a schema and some sample data that you can install so you have something local to work with as you build this application. Here is a view of the ER diagram of the database. There are a lot of tables I'm providing here, but we're only going to be building out a certain subset. We'll be focusing on speakers and sessions and their relationships. Even though this subset might not look like much, it's enough to cover concepts like many-to-many relationships, handling binary data for images, foreign keys, and all of that fun stuff that you end up dealing with in a real-world application. To help you get your database set up locally, simply head over to your browser and go to the following URL, github.com /dlbunker/ps-first-spring-boot-app. And this repository will contain database help to get you up and running. So simply jump into the database/postgres folder, and you can see that there is two basic files here, create_tables and insert_data. But before you can do that, you actually need a database. You have a couple of options. If you have a local postgres database instance already set up, you can simply log in with PSQL and perform the create database command, switch to that database, and then run the create_tables file followed by the insert_data file. If you don't have a local postgres instance available, the next easiest way is to run postgres in a Docker container. I've included instructions for this, and they're available in the readme file on the GitHub repo in this folder. At this point, go ahead and get your database tables installed, and add the data to it, and then come back to the video when you're ready. I'm using a postgres database client called Postico, but any database client that you are familiar with or can work with will be just fine to use. Just make sure that before moving on, you have your database set up and you can connect to it. In this case, you can see all of my tables are listed here. And if I go look at sessions, I can go into one of these, and you'll see that I have some session data inside of the session table. One thing that you'll want to note here is that the URL that you use to connect to your database, you're going to need that information available because coming up, we will actually use that to connect Spring to the database.
Demo: Connecting to the Database
The Spring Boot app is created, we have a database in place, and we have a basic overview and understanding of what we're going to be building. So first up, we need to add a starter dependency that will include the Spring Data JPA library and then connect it to Postgres. If you remember, in Spring Boot, all of our dependencies are managed in the Maven POM file, so I'm going to go ahead and open that file up, and I'll scroll down to the dependency section. Underneath the spring-boot-starter-web dependency, I'm going to add the new dependency like this called spring-boot-starter-jpa. Since we're also using a Postgres DB for this application, we need to add the Postgres JDBC driver dependency so that we can properly connect to the database. We can do that by adding this dependency. Go ahead and save the file, and you'll notice that IntelliJ is asking you if you want to import the Maven changes that you just made. We do want to bring these in, so I'm going to go ahead and click on that link to have those pulled in and added to my project. Once IntelliJ is done synching the dependencies, we can go ahead and close that tab. At this point, we're almost done with getting connected. The last piece is to tell Spring Boot what the Postgres connection URL is. That information will be added to our properties file, which in Spring Boot, will be in src, main, resources, application.properties. Go ahead and open that file. Currently, this file is empty. I'm going to go ahead and add the following properties. If you remember from the previous clip, you need to know what your URL is to your database. In this particular instance, my URL is located here at the datasource.url property. Your URL might be slightly different depending on what port you're using, what you named the database, and so on. I've also managed to set up my database that doesn't require a username or password. Yours may need this information, especially if you're using the Docker container. And the last three properties should be able to be universal, and you can set those as seen here. I'm going to go ahead and save the file. And at this point, we're now done getting Spring Data JPA and JPA installed into our application and connected to our database.
Demo: Creating JPA Models
We could begin by creating some controllers and working down the architectural stack, but I actually want to take a bottom-up approach in this course. If you started with a good database and schema, that will give you an excellent base for the rest of your app. Since we just finished connecting to the database, the next step is to apply some JPA entities so that we can talk to the database structures. Let's start by heading over to the model package that we created earlier. That's be in the java folder in the com.pluralsight .conference, and you'll see that there is the models package. To add a new JPA model here, I can simply right-click, go to the new menu, and say Java class. And we'll go ahead and begin by creating the session class, which will map to the conference sessions. So the name for the new Java class will be Session. Hit Enter, and we have a new plain Java class. Next, we need to annotate this as a JPA entity, so I can do that by adding a class-level annotation at the top. Anytime you bring in a new entity or object, you'll also need to import that, and IntelliJ can help me with that by clicking on the Import class. We want to choose the javax.persistence Entity class for our import. I've also given it a name of sessions because that is the name of our database table. In the database, we have a plural name for our database table, and the class itself is called Session singular because it will be one instance or row of that data. Next thing I'm going to do is add a default constructor to all of my entities. This simply helps with serialization and deserialization, which will happen when we plug in the controllers later on to marshal the data into and out of JSON. You could use IntelliJ to create the constructor, but it's simple to just create a public session constructor. I can now map the table columns to the Java attributes in the Session class. I'm going to add the following class attributes with their appropriate data type. A quick sidebar discussion here, I want to mention something about conventions. Notice that the variable names aren't technically Java standard camelCase names. I'm keeping them the exact same name, spelling, and format as the database columns. By doing this, JPA will auto-bind to those columns, and I don't need to annotate them. If I wanted to change them to match standard Java camelCase, I can do that by simply adding an @column annotation on each attribute and mapping it appropriately. Since we're not diving too deep into JPA in this course, I'm going to leave this as is for simple speed and convenience. There is one annotation that I do have to add, and that is the id annotation to specify which attribute is the primary key. So above the session_id attribute, I'm going to add the following code. I'll go ahead and import the classes as needed. For Id, we want to use the JavaX persistence Id. This tells JPA that the IDE is the primary key field and that the GeneratedValue annotation specifies how the primary key field gets populated on a new record insert. By using the IDENTITY strategy, JPA will utilize the Postgres created sequence for primary key values. Here's the table structure for the sessions in the Postgres database, and you'll notice that the database PRIMARY KEY fields are set to the serial data type. When you create a table with serial data type, it creates it as an integer and add an auto sequence to it, which you can see here, the sessions_session_id_seq. This means that Postgres will generate a sequenced auto-generated number for your primary key whenever you insert a record. Finally, the last thing that we need to do is create getters and setters for the attributes we've added. IntelliJ can do this quickly simply by right-clicking in the class, clicking on the Generate menu item, selecting Getters and Setters, then you can select all of the attributes, and click OK. You'll see that IntelliJ added them at the bottom of the class. I can go ahead and save that file and make sure that I don't have any compiler errors anywhere, and that's it! We've created one entity already. What I'd like you to do now is build out an entity for the Speakers table. Go ahead and pause the video and build everything in that table similar to what we did for the session entity, except do not add the speaker_photo field. That's a binary field, and we'll deal with that field later in a later demo. once you're done, go ahead and restart the video and check back with how you did compared to my solution. Okay, here's what I have for the Speaker class. You'll notice that I placed it in the models package and that I called it Speaker. I then added the annotation @Entity, gave it a name of speakers, which maps to the actual table name, which is plural speakers, but the class is singular. I then added the attributes from that table with the exception of the speaker image. I then created a primary key by adding the @Id annotation and the @GeneratedValue annotation. I created a basic empty constructor, and I added all of the getters and setters. If you didn't end up with something similar to that, go ahead and fix up your code before moving on. At this point, hopefully you're asking yourself, what about the relationship between speakers and sessions? In the database, we have a table called session_speakers. How does that all work? That's what we'll be covering, coming up next!
Demo: Working with JPA Relationships
Now that we have two entity models in place, we can tie them together with a JPA relationship that will match the database table relationship. Speakers and sessions are connected via a union or join table, so we need to set up a many-to-many relationship in our models that will match that database relationship. Let's start with the Session entity. You need to pick one side of your relationship to be the owner or main definition point of the relationship. I'm going to use the Session class for this. I'll begin by adding a list of associated speakers by adding a new attribute, like this. This is pulling in a list of speakers now, so you'll need to import the List class, which is from java.util, and this ends up just being another field on the Session entity, so I need to add a getter and setter for that. So I'll click down here and just go to Generate Getter and Setter. I can select the new value, click OK, and I now have a basic relationship on the one side of the many-to-many. Next comes the hard part with defining the relationship. To tell JPA how this works, we'll need to add some annotations over the attribute, like this. We need the @ManyToMany annotation, go ahead and port that, the JoinTable, the @JoinColumn, and the definition for the JoinTable. Here's quickly what these annotations mean. The first ManyToMany means that you're setting up a many-to-many relationship and that you have a mapping JoinTable in your database. The second annotation defines that JoinTable and the foreign key columns. So in this case, the table is session_speakers, which has a session_id and a speaker_id foreign key to the appropriate tables in the relationship. Now that this is defined, JPA will set up the SQL join automatically for you when you make a call to the speakers attribute. Let's go ahead and jump over to the Speaker entity, and the last thing that needs to happen is we need to define the many-to-many relationship on the speakers side. This will make the relationship bidirectional. Again, I'm going to add the attribute pointing to Session and generate getters and setters for it. So it will again be a List type, so we'll have to import the java.util list. This time, we're pointing back to sessions, and we can create some getters and setter for it, right-click and generate them, and save the file. The annotation on this side of the relationship is a little easier since we simply need to specify that it is the other side of the existing many-to-many relationship. We can do that by adding this annotation. We'll import that class, and you'll notice that it's mapped by speakers, which is referring to the attribute on the Sessions class called the speakers. And that's it for our relationships. We just have one last piece to deal with on the entities, and that is the speaker photo, which we'll deal with next.
Demo: Working with Binary Data Types
I'm back on the Speaker entity, and I'm ready to deal with setting up the speaker photo. This ultimately means that we have binary data so that we can store the photo. And working with binary data can be a pain, and we need to handle a couple of gotchas to get things running correctly. Let's begin by defining a class attribute for the speaker photo column. That will look like this. Notice its data type is a byte array, which is well suited for binary data in Java. Next, we'll go ahead and add the getters and setters in IntelliJ, right-click, and generate those, and save the file. To get JPA to stream the binary data into this field, we need to add a couple more annotations. Import the type class as the org.hibernate .annotations and make sure that you're Lob class is imported as well, and let's quickly talk about what these annotations do. The first annotation is a Lob, and it stands for large object. Binary data can get really large, and this annotation helps JPA deal with the larger data. The second annotation is needed to help Hibernate deal with binary data. In our case, Hibernate is the JPA implementation that we're using under the covers. Without this annotation, you'd ultimately end up with an exception when JPA queries the data and tries to push it into the Session instance. Finally, there's one last piece of configuration needed to get JPA, Postgres, and binary data all happy. I'm going to jump back to the application properties file, which if you remember, is in src, main, resources. Open that. I'm going to add a new property that looks like this. This property is needed so the Postgres JDBC driver can create a Lob correctly on the Java side. Again, without this property configuration, you'll get exceptions when you try to run the application. A note on binary data, these little issues can be troublesome when you're working through your app from scratch and you have not encountered them before. Hopefully this part of the course gives you enough of a background that you can get past these problems and have a solid app base to work on some of your own app needs going forward. We're finally finished with the JPA entities. Let's go ahead and move up the architectural stack to repositories.
Demo: Creating JPA Repositories
Once your entities are in place, you have a couple of choices with how you want to handle your data access layer. I'm a big fan of Spring Data JPA and all the benefits it provides out of the box. That's what we'll go ahead and set up now by creating some JPA repository interfaces. Take a minute and jump back to the pom.xml. If you remember, we added the Spring Data starter into the POM as one of our dependencies. This pulls in the libraries we need to work with JPA repos. Since we started with the session entity first, I'm going to go ahead and begin by creating the session repository. This is a slightly different area of the architectural stack, so I'm going to put that in the package called repositories. That package is over here by the models. To add this, I'm going to right-click and say New, Java Class, I'm going to select an interface because our JPA repositories are interfaces, and I'm going to call the interface SessionRepository. This created a new Java interface. JPA repositories are almost too easy to set up. All we have to do is add this to the interface definition. We want to extend JpaRepository, and we are going to use Session as our data type, and Long refers to the primary key. Go ahead and import the Session class, and the Session class is the one that we created, and we'll need to import JpaRepository as well. And that's it! We now have Find, Update, Save, Delete, and a bunch of other operations already set up and usable for us on our Session JPA class. Go ahead and pause the video again and create a repository similar for the Speaker entity. Once you're done, restart this clip and compare with the solution I'm about to show. Okay, here's what I've come up with. I've added it to the Repositories package, similar to Session, and it's really similar to Session. It's just that we've typed the Speaker entity instead of the Session entity. That's really the main difference other than the interface name. At this point, if you are caught up and you have your entities and repositories all wired up, we're ready for the last big effort, and that is creating the API controllers.
Demo: Creating Spring API REST Controllers - Part 1
We now need to create some controllers. These controllers will handle our API endpoints, and they're going to be REST based. Again, we have a package that we've defined for these called controllers, so I'm going to jump over there and create a new class in the controllers package. Right-click and say New, Java Class. I'll again start with the Sessions section, so I'll create a controller called SessionsController, leave it as a class type, and hit Enter. The next thing we need to do is add some annotations so that Spring MVC knows that these are controllers. So I'm going to add that at the class level. Import the classes for the annotation. So quickly, what these mean is the @RestController means that this will respond to payloads incoming and outgoing as JSON REST endpoints. The @RequestMapping tells the router what the mapping URL will look like. So in this case, I'm specifying the route path is /api/v1/sessions. All requests to that URL will be sent to this controller. The next thing I'm going to do is use Spring to inject or auto wire the sessions repository that we just created. Go ahead and import the missing classes, and that's what this will look like. So Spring will auto wire this when our SessionsController is built. It will create an instance of the session repository and put it onto our class. Next, I'm going to create a list endpoint. This will return all of the sessions when called, so I need to create a method that looks like this. Go ahead and import the missing files. Another thing to note really quick about REST controllers in Spring MVC is the return types. By default, the REST controller will return 200s as the response status for all the calls. Even though we added the @PostMapping annotation to this endpoint, it's not going to infer anything from that. Because typically, when you create something or you post something, you get a 201 back, but the Spring REST controllers just will return a 200. So one way that you can override those would be to add the following annotation to your endpoint. By including the @ResponseStatus annotation, you can specify the exact response that you want to occur when the method executes and finishes. So in this case, I've given it an HttpStatus of CREATED, which maps to 201 in the HTTP world. Since this isn't in-depth REST course, I'm going to go ahead and just remove the ResponseStatus, and I'm going to leave the 200 responses for all of our endpoints, even though that's not typically what you would do in real life, but that it could be something that you could go back in and add yourself by thinking about what is the appropriate response for GETs, CREATEs, PUTs, DELETEs, and so on, and put the ResponseStatus mapping in correctly. A couple of things about this method. I haven't given it a specific RequestMapping. That means if you were to make a call to api/v1/sessions, it's going to route to this method. The annotation GetMapping tells which HTTP verb to use, which will be a get verb to call this endpoint. Next, I've used sessionRepository, and I'm calling the findAll on it. This is how powerful the JPA repositories are. It built this method for us, and it's going to go out and query all of the sessions in the database and return them as a list of Session objects. You'll notice that our data type is returning that list of sessions, and Spring MVC will then pass that over to Jackson, which is a serialization library, which will turn those sessions into JSON and return them back to the caller. The next REST endpoint I want to add is the ability to get a specific session by ID. So I'm going to add this method, I'm going to import the classes, and let's talk about what this does really quick. Again, the @GetMapping is like the other method in that we're using the HTTP verb GET when we call this method. The @RequestMapping is in addition to the class RequestMapping. So in this case, our class RequestMapping is api/V1/sessions, and the RequestMapping on this is adding an additional id to the URL. This id is specifying a specific session, and we want to return that. The parameter on the GET is pulling that off of the URL and injecting it into our method automatically. Again, this is handled for us by Spring MVC. We're using a PathVariable. And since we have Long data types for our primary key, we're going to marshal it into a Long type and set the id on the incoming parameter. At this point, we can then use the Session repository, and again, it's auto built this method called getOne where you can pass in an id, and it returns and queries the session for that id back to the caller. Once we get it back, we just return that. And in our controller, we're auto marshaling the session, which will return the specific session back to the caller in JSON payload. For the two read portions of a CRUD, or create, read, update, delete REST endpoint, these two fill the listing and the specific id. We'll go ahead and pause there. And if you've already guessed what's going to happened next, you get to build out the speakers controller. So go ahead and pause the video and get the speaker list and a specific speaker controller endpoint to return a speaker back to you going. Then go ahead and fire the video back up and compare to what I've built myself. Okay, here's what I have for the speakers controller. I added it again to the controllers package. I then called the controller SpeakersController. I changed the RequestMapping to take routes that are coming for /api/v1/speakers. I auto wired in my SpeakerRepository, which gives me CRUD access and other access to my Speakers database table and data. I then created a List method, which returns all speakers if you call it. That is using the GET HTTP verb. And I created a GET method, which returns a specific speaker, and again, we're looking for a speaker with a particular id, which we'll pass in from the URL to our parameter, PathVariable Long id, which we can then pass to the SpeakerRepository, and that will return our Speaker, which will return to have JSON marshaled. That's it for this portion of the controller as part of the course. Coming up next, we'll build out the update, delete, and insert functionality for our CRUD REST endpoints.
Demo: Creating Spring API REST Controllers - Part 2
The next piece that we'll set up in our controllers will be the create, update, and delete API endpoints for the sessions and the speakers. So I've opened up the SessionsController, and we'll go ahead and start there. Let's begin by creating the create method, so this will create a new session, and if you pass a session info to the API endpoint, it'll create a new session into the database. At the bottom of the controller, I'm simply going to add this new method. We'll import any missing classes, and let's take a look at what's happening. So the first thing that you should notice is that we're using an @PostMapping. This is saying that we're requiring the HTTP verb POST to be presented with this API call. We did not give it a request mapping because, essentially, we're posting to the base part of the class, which is the api/v1/sessions endpoint, using the POST verb. Now here's where it will get interesting. In the create parameter section, we've had an @RequestBody annotation, and then we have a session object that's passed in. What is happening here is Spring MVC is taking in all of the attributes in a JSON payload and automatically marshaling them into a session object. Once it does this, we can simply pass that to our SessionRepository, which is part of Spring Data JPA, and we can save and flush that. A quick note on save and flush. When you're using JPA and entities, you can save objects as you're working with it, but it actually doesn't get committed to the database until you flush it. So the SessionRepository and the JPA repositories, in general, provide this one method that will do the save and the flush all at once as you pass in JPA entities to it. The next endpoint I'm going to create is the DELETE endpoint. Here's the method implementation for that. Let's talk about the annotations. The @RequestMapping is specifying that you need to pass in an id similar to what we did on the GET saying that you have to have an id, but we're also adding a different HTTP method to this using the request method DELETE. So this requires the HTTP verb DELETE presented with this API endpoint. You might ask why we don't just call @DeleteMapping, and that's because Spring only provides @GetMappings and @PostMappings. If you use a different verb, you have to specify it in the RequestMapping attributes. Again, the parameter for the DELETE takes in an id, and this is pulled off of the PathVariable, similar to the GET. And once we have the id of the record that we're going to delete, we can, again, call the Spring Data JPA repository to delete it by the id. I've added a comment here, and this is just applicable to anytime you're deleting records in a database with JPA that you'll have to deal with cascades. So for example, if the session has children records, this would not allow it to delete. We'll get a foreign key constraint violation when we issue the DELETE call to the database. One thing that you can do for extra credit or homework would be to put in logic that allows the deleting of the children records for sessions. And there's a few ways you can do this. I'm not going to give you any hints on that, but it'll give you the ability to research it and try a few things on your own. But just keep in mind that this will only delete session repositories without any children records at this current implementation. Finally, let's look at an implementation for updating a session record. So I've pasted in the actual update implementation. I'm going to open the screen here so we have a little bit more room to see what's going on. First, let's begin with the @RequestMapping annotation. Again, we're requiring the id on the URL, similar to the DELETE and the GET endpoint. And at this point, we're changing the method to an HTTP verb PUT. One note on REST implementations. When you're updating a record, you have two verbs that you can choose from. You can choose from the PUT and the PATCH verb. It's kind of up to you how you want to implement them. But typically, the PUT will replace all of the attributes on the record that you're updating, and the PATCH will allow just a portion of the attributes to be updated. So this implementation will take all of the attributes in on the request body for that session and replace them all on the database record. Jumping down to line 42 here, let's take a look at what's happening. So in order to update a record, we first need to get the existing one. So we're asking the SessionRepository to find the record by the id, which is coming off of the URL parameter. We're storing it in a session variable called existingSession, and next, I'm using the BeanUtils object, which we still need to import, and the BeanUtils object takes the existingSession and copies the incoming session data onto it. The third parameter on the copyProperties method allows us to ignore properties on the entities or Java object that we do not want to copy over from one to the other. In this case, we want to ignore the session_id attribute because that's the primary key, and we don't want to replace it. If you don't ignore it, you'll essentially copy null onto the primary key. And when you go to update that onto the database, that will cause an exception to occur because the primary key cannot be null. And finally, we're using the old trusty saveAndFlush method again on the existing session, which has now been updated with our attributes on our Session JPA repository. I've added a couple of comments here at the top of the method implementation just to kind of keep in mind. First, because this is a PUT, we're expecting all the attributes to be passed in. If they're not all passed in, those attributes will be updated with null. If you only need to update certain attributes of your JPA entity, you should look at implementing the patch version of this update. And finally, we're not doing any kind of validation. And since we're requiring all the attributes, it would probably make sense to check that they're all there. If they're not, you could return a 400, which would indicate a bad payload passed to the update API endpoint, and that's it. If we take a look at our actual controller now, we have a full CRUD controller for the sessions. We have a LIST, a GET, a CREATE, a DELETE, and an UPDATE, and this fills out all of our CRUD operations for a proper REST resource, which in this case, is Sessions. So again, it's time to pause the video. I want you to update the SpeakersController with a CREATE, UPDATE, and DELETE method, similar to what we've done here for the Sessions. And once you're done, go ahead and turn the video back on, and we can check my solution with what you've come up with. Okay, here's what I have for the SpeakersController. It should look very similar to the SessionsController. We have a create method implemented. The only difference is that we're working with Speaker objects rather than Session objects. The DELETE method is doing something very similar, just deleting by the id. Again, note that we're using speakerRepository rather than the sessionRepository. And finally, the update is doing pretty much the same thing as the session update with the main difference that we're using the Speaker on the RequestBody, and in the ignoreProperties, we're ignoring the primary key of speaker_id rather than session_id. At this point, we pretty much have our micro service conference API app coded up and ready to test out. That's what we'll do, coming up next!
Demo: Handling Serialization Issues and Running the App
Now that our controllers are created and updated, we're ready to test this out. So I'm simply going to start up the application, and let's see what happens. In IntelliJ, if you want to start the application, you can find the ConferenceDemoApplication object, double-click on that or just select it in the Project explorer area, right-click and go to the Run menu. If all is well in your application, you'll get a notification that we have our application started on port 8080, and it's ready to try out. I've jumped over to Postman, and Postman is a tool that allows you to work with API endpoints. You can get it from the URL getpostman.com. Once you have it installed, you can enter endpoints and URLs to test and try out. If you remember, our application is running on port 8080, and I'm running locally, so I'm using localhost port 8080, and our session's endpoint begins with api/v1/sessions. I don't need to pass in any headers or body, so I'm simply just going to try this out. And before I do, note that we're using the HTTP GET verb. You'll notice that we'll get a payload down here, and you'll see that we have a lot of information pulled back. It's actually pulling back a bunch of nested data. You can see this here. It keeps getting deeper and deeper, and this is kind of a problem. This is actually a serialization problem. You can try out speakers as well. And again, we get the data back, but it's looping cyclically over our many-to-many relationship. So let's jump back over to IntelliJ and see how we can handle this. So sometimes your cyclical payload serializations will actually get so large that you'll get exceptions because it'll just go infinitely, and it'll blow up the stack on your Java stack. So to help with this, you can jump into your models and place some annotations on there that Jackson library will look at and help to serialize your payload. The other option that you could do is to create DTOs, or data transfer objects, but I'm simply going to use my entities for entities, as well as data transfer objects. So if you remember on the session, we have a many-to-many relationship set up that's going out to speakers, and this is what's causing that cyclical problem. Because as we go out to the speaker, the speaker is on multiple sessions, and as we go into the session, the session has multiple speakers, and it keeps going over and over. Since we defined the session as the dominant side of the bidirectional relationship, we'll go ahead and leave this alone and jump over to the speakers version of the many-to-many relationship. On this one, we can add a new annotation that will prevent it from back serialization back to the sessions. We can do that by adding the @JsonIgnore. You'll need to import that, and you'll see that this comes from the Jackson library. So Jackson is going to look for this and ignore that when it goes to reload the sessions. I can now go ahead and restart the server and try the call again. To restart the server, you can just click on this encircle or recycle arrow to restart the server. Once that's up, we can jump back to Postman, and let's go ahead and try the sessions again. At this point, you'll notice that the payload has changed. The payload loads in a session. It loads in the relevant speakers for that session, but it does not continue to go deeper and deeper because of that JsonIgnore annotation we put on the speaker entity. Let's go ahead and test a couple of the other controller endpoints. So the next one is the GET where we need to pass in a specific id. You can see that we have one here, session_id of 2, so I'm going to pass that in on the URL, and we should just get this one session back. Uh, oh! You'll notice that there is an error that's occurred on our call. This is another serialization issue with Spring and Hibernate. Let's jump back to IntelliJ, and we can see how to fix this particular problem. You'll notice that it's complaining about the ByteBuddyInterceptor. So again, we'll deal with serialization issues on our models. So I'm going to go to the sessions model or entity, and I'm going to add a new annotation at the top at the class level that looks like this. The @JsonIgnoreProperties, we'll go ahead and import that class. This time, we're ignoring a property called the hibernateLazyInitializer and the handler property. When you create an entity and you have a relationship on here, Hibernate adds a few stub methods to handle lazy loading and eager loading of the relational data. When you go to serialize a Hibernate object, you do not want to serialize this because this will try to load in all of your relational data with SQL, and it can cause problems. And in fact, our problem right now is we have an exception. So I'll save this file, and I want to add this as well to the Speaker class. Again, I'll save those files and restart the server. So back in Postman, let's go ahead and try to get the session with the primary key id of 2, again, by calling Send. This time, you'll notice that we did not get an exception, and we have a valid payload back, and it's just the one, it's just the one for primary key of 2. We'll go ahead and test out the Create. In Postman, when you're creating something, you want to set the HTTP verb to POST, and you need to pass in a body. You can do that on the Body tab here. I've selected the raw with the JSON payload so I can pass in a payload here, and we can see that I have given my new session a name, a description, and a length. Down at the bottom here, you can see that we have a status of 200, meaning that it succeeded, and we have a new session. It's been issued an id of 94. This is what the sequence on the Postgres database automatically did for us. And we have all of the data that we passed in. We can try an update. Again, if you remember, the update takes the PUT verb, and let's go ahead and update the session that I just created, which was 94. We'll take a look at the updated attributes. Again, we're requiring all three of these attributes because it is a PUT rather than a PATCH. We'll send that off to the server. Again, our status is 200 OK, and you can see that the data coming back was we updated session 94 with the new data we passed to it. And finally, to round out our CRUD endpoints, we can try the DELETE out. Since we created a new session with id 94, I'll just go ahead and delete that because I know it does not have any children data. We don't need to pass anything into the body, and we change the verb to DELETE, send that off, and we got a 200 back. So if you got a 400, or a 404, or a 500, those are all problems that have occurred. Either the URL is wrong for a 404. If you've got a 500, there's some kind of a exception happening on your server, and that's where you'll want to go ahead and jump back to IntelliJ and look at the console output. This is where all of the problems will show up, and you can see anything that has happened here that might have caused an error. And that's it! I'll go ahead and let you try out the speaker endpoints. Assuming everything is working for your speaker endpoints as well, we have essentially built a full-blown application on the server side in the last 25-30 minutes. You can see that Spring Boot is very quick at building things, especially, if you're familiar with the other Spring frameworks, like Spring MVC and Spring Data JPA, as well as JPA and entities.
Summary
We've accomplished a lot in this module. We've touched and worked with a variety of Spring architectural concepts in the Spring Boot environment and have a working backend conference app. Just keep in mind that we went really fast through this. To get a deeper understanding, you will need to dive into each portion of Spring that we covered and worth through the details. So let's recap what we've built. Once we've determined what our conference app would do, we installed and got a Postgres relational database running as the foundation of our app. I provided the schema and data files from a Git repo to bootstrap the database. Next, we worked our way up and built out some JPA models and repositories that comprised the persistence tier of our architecture. This included connecting to the database and setting up model relationships. We then built out the API endpoints that would be needed for basic CRUD operations on sessions and speakers. This utilized the Spring MVC framework, which relied on REST controllers and the Jackson library for JSON serialization. We did deal with a few other nuances, like working binary data and serialization issues. You'll always find one-offs like that when building an application that you will have to work through eventually. App development tends to follow the 80/20 rule, like most things in life. Eighty percent will build out easily, and 20% will give you more headache. And that's it. Take a break and regroup. Because coming up in the next section of the course, we'll dive deep into all the ways Spring Boot can be configured and managed.
Working with Spring Boot Config and Environment Needs
Introduction
The last section of the course was fast and furious, but we managed to get a working API application up and running. Now that we have that, we can take a deeper in-depth look at how to customize our app the Spring Boot way. If you're working on an application as a team, you often run into the problems like how do you prevent coding in the production database credentials in a configuration file and then checking that into source control where everyone can have access to it, or how do I set up application configuration for different environments? In staging, you want to enable full logging, but in production, you want to only log errors and warnings. We'll answer these questions, as well as dive into a few other good to know Spring Boot configuration tips and tricks, coming up next!
How to Customize and Override Spring Boot
The good news with Spring Boot is that it provides a lot of ways to override and customize your application. In fact, there is more than a dozen ways to set a property value for your app. The bad news is there is an order of precedence that Spring and Spring Boot uses to properly set your values. If you're not careful, you can have a property set incorrectly if you aren't aware of this. First off, there are two basic places that you can put your configuration. You can use something external to the app like command-line parameters, environment variables, or JNDI stores, or you can use something internal to your application like servlet parameters, property files, and Java configuration. Keep in mind that your internal configuration tools can also point to external sources. Since there are a variety of ways that you can set up your configuration, you should be aware of how Spring Boot handles reading and setting them. Here is the basic order excluding test configuration setup. The main rule of thumb is external property sources override internal property sources with the exception of servlet config and servlet context parameters. Those take precedence over JNDI, system properties, and environment variables. So here is my advice and a side note on how you should think about properties. You should pick one internal source, like property files, to set up your application defaults and then pick one external source to provide overrides. This keeps configuration in one of two places, allows for sensible defaults, and then gives you the ability to use external sources for sensitive data, like credentials and passwords. I'm going to follow my advice in this course and use OS environment variables as the external source and application property files for the internal source. Coming up next, we'll start working with the basic application property files as our main internal source for configuration.
Demo: Locating and Working with Config Files
Apps set up with an even layout separate out Java source files from other types of files. This means that the application property files for your Spring Boot app are located in src, main, resources. So I'm going to go ahead and open up that folder, and you'll notice there's a file called application.properties. We'll reopen that because we've already made some changes to this file. When we set up the app, we added the data source in jpa.properties to this file so that our app would work correctly. One thing that you should know is these properties are actually overrides of Spring Boot default properties. I've jumped over to a browser, and I've opened up this URL to this Spring Boot Common application properties. If this URL goes out of date in the future, simply go to a Google search and look for Spring Boot Common application properties, and you'll be able to find this Appendix A. Spring Boot and Spring Boot starters provide a setup of default properties, and these properties provide sensible defaults, as well as provides an application developer the ability to customize the application with having to write or change code. If I take one of the properties we configured, like the spring.datasource .url, and search for it, you can see the default, which is null, and see what starter or system the property comes from. In this case, it's handled by the DataSourceProperties. As I scroll up, you can see it's coming from DataSourceProperties, as well as the DataSourceAutoConfiguration class that Spring Boot provides in the Spring Data JPA starter. Let's try taking another default property and changing it in our application. The app, by default, runs on port 8080 as you've seen when you ran it after we built the app. So let's go ahead and change that. We want to find a property called server.port. You can see that the default value is set to 8080. So how do you think that we could change this to say port 5000? Well, all we need to do is simply put this in our property file and override it. So I'll go ahead and copy this value and jump back to IntelliJ. Back in the application.properties, we can simply add that new property to the end of the file and override the value to port 5000. If I save that file and restart the application, come down to the Run tab to do that, and start up the application, you can see now that Tomcat is started on port 5000, and that's all it takes to override the Spring default common application properties to simply put it in your application and provide the value that suits your needs. Next, let's take a look at overriding app properties with external configuration.
Demo: How to Change Database Connections
I'm back in the application.properties file, and I want to adjust the database connection info. Maybe I'm getting ready to deploy to production, or maybe my database got moved, or something has changed, and I need to deal with it. The first thing that you should take note of is that the database URL and credentials are currently hard coded into the app. This info is your production database info, and you check your code into a public Git repository, all of the sudden, everyone has credentials and access to your production database. So the best way to solve this is to simply not hard code your database info in the application.properties file. Let's go ahead and move it to an external environment variable. Spring Boot handles property placeholders in the application property file. First, I'm going to copy the URL and remove it from the app properties file. Next, I'm going to replace the value with this. This tells Spring to look for a property called DB_URL and set its value on the datasource.url. In order to do this, we need to set up an environment variable to handle that URL. Once that's done, none of the info is actually _____ into the source code, but I can still run my application. To add an environment variable to the IntelliJ, you need to click on the Run menu and go to Edit Configurations, find the ConferenceDemoApplication configuration and jump down to the Environment Variables box. In here, we can add the name of the environment variable, which is DB_URL, and we can paste the value that we pulled out of the application.properties file into here, click OK to save that, we'll go ahead and apply this, and click OK to exit. So at this point, my app is now configured to read an external property value for the database URL. You'd most likely want to do the same for the username and password properties so that sensitive data isn't hard coded into the file. To test this out, we can go ahead and restart or run our application, and at this point, IntelliJ is saying Tomcat has started on port 5000, but you can jump over to Postman really quick just to test out we can get data from our database. Back in Postman, I can test my sessions out again. But if you remember, we changed the port of our application to 5000, so I'll need to update that as well. Once I'm on the correct port, I'll go ahead and send the request to the server, and you'll notice that we still got all of our data, even though we pulled the database URL out of the applications file and into an environment variable. At this point, if you happen to deploy your application in production, you can simply provide the production credentials as an environment variable, and your app is now pointing to an appropriate data source for that environment. This is one way that you can handle environment-specific configuration. Spring Boot also provides another way to handle environment configuration, which we'll take a look at next.
Demo: How to Handle Different Environments
Getting processes in place to be able to handle your app in multiple environments is something most teams will end up doing over the life of any serious project. At some point, you might ask, how can I work with an app in development locally then deploy to a nightly test server, staging, and finally, into production. Spring Boot uses a combination of Spring profiles and profile-specific application property files to accomplish this. Simply add any profile suffix to the application part of the file name, and Spring Boot will use those properties instead of the default application.properties file. To specify the profile, you have to use a spring.profile .active -D parameter on your app startup with the profile name to activate whatever profile you want to run. In this case, the dev profile would be activated, and Spring Boot will look for an application- dev.properties file on the class path, which would be in src, main, resources of our project. Let's go ahead and set up a new profile configuration. I'm back in IntelliJ, and I'm going to go ahead and create a production-specific property file. So under src, main, resources, I'm going to create a new file. Since this is for prod, I'll call it application- prod.properties. For production, we probably want to trim down the logging to just errors or warnings. We can add some properties to the file that will do just that. You can adjust the logging level on your application to anything in the org package to just print out WARN or error messages by using a property like this. I'm going to make sure my application-prod properties file is saved. And really quickly, if I open the Run section, you'll notice we have a lot of log statements when the server starts out that are INFO, or WARN, or other scopes in the log file. The logging level that we just set says we only want to see WARN particular log statements, and so we want to remove this INFO for production. So we can test that our by setting the profile on the run configuration, so we'll go ahead and reopen the Run, Edit Configurations section of IntelliJ again. This time, we want to utilize the VM options, so I'm going to select in here, and I'm going to add the following -D parameter, spring.profiles .active, and it equals prod. And note, prod has to match the suffix that we've given our property application file. Go ahead and apply that and close this. Then we can go back to the Run tab and rerun the server and see if our log files are reduced because now we're in production mode. Okay, so the application has started, but you might be asking, why am I still seeing INFO messages? I should only be seeing WARN messages. Well if you remember, we only set WARN messages on any code that begins in the org package, so these codes over here begin in com. It's not going to take effect. But overall, you'll notice that the log output is substantially smaller using the prod profile. Since we're still in development mode with this application, we'll go ahead and remove that from the run configuration, just in case we do run into errors later, we can see them. Coming up next, we have even more configuration options with Spring Boot.
Demo: Setting Properties with YAML
So far, we've been talking about property files, which have been a staple in Java since forever. Let's see what it would take to use newer YAML-based files. These files will pretty much work just like a properties files in the sense that it needs to live on the class path and it needs to be named application.yml. The nice thing about Spring Boot is that you can mix and match property and YAML file types. To show how that works, I'm going to move the server port from the application.properties file to a new application.yml file. That leaves the JDBC connection for the database in one file and the server port in another. So I'll begin by going over to application.properties and removing the server.port configuration property. Next, I'll create a new file in src, main, resources, and I'll call it application.yml. I can now paste the server port into the YAML file, but I'll need to adjust it because YAML files are not configured like property files. YAML files show hierarchy and nested properties fairly well. And so if you have a lot of complex, really deep properties, YAML files work well for that. So I'll make sure my property files are saved, and I'll go ahead and restart the server. If I go look at the output, you'll notice that the Tomcat server still started on port 5000 even though I removed it out of the application.properties file. Some advice for your project, even though you can mix and match property file types in your application, I'd recommend picking one format and sticking with it. You want to try and isolate your configuration for your setup in your application and keep it as simple as possible. Last, environment profiles also work with the YAML files. We could simply append a -dev or -prod to a YAML file, and it would work exactly like application property files do using a Spring profile from the command line. And at this point, we know just about everything there is to know about property files in Spring Boot, so let's check out what you can do with custom properties.
Demo: How to Use Spring Properties in Code
So far, we've only modified existing Spring Boot and starter default properties. In this particular demo, we're going to add a custom property called app.version and create a controller to display the app version when called. I'm just going to jump back to the application.properties file and add that in there, and I'll create a new property called app.version and set it to 1.0 .0. This is a completely custom property that I want to use in my application, and it has no correlation to anything that Spring Boot provides. This custom property represents the version of our application, and every release, we could bump the version just so that you know which version of code is running when you access the API. Adding the property is not enough. We actually need to create a controller to actually spit out the property when you call the home of your application. So I'll go jump back to the Java source code, and I'm going to find the controllers package, and let's create a new controller called the HomeController. Do that by calling a new Java class, and I'll call that HomeController. This is like any other controller. We need to annotate is as a REST controller and import that, and we can create a root or default handler for this by adding the following methods. We'll make it a GET HTTP verb method. We'll have that return a Map type, which is part of the java.util collections, and it will service the root or home section of your application. Since Jackson is our marshaler for objects to JSON, it'll take the map and its key-value pairs and just print them back out to the response as a JSON payload. So before we implement the method body, now comes the cool part. We can inject the app version that we just created into the controller by doing something like this. I can use the @Value annotation, and you'll notice that I have a dollar sign and curly brackets, and I've specified my app.version. This custom notation tells Spring Boot and Spring to look in the properties section of the app and find that and inject the value into the private String app.version attribute that I've created. Now all I need to do is set that in a map and return it in my method. I can do that by instantiating a new HashMap, setting it to the Map interface handle, I can then do a map.put, store the app-version and the version from the properties file into that value of the key-value pair, and then finally, return the map, and Jackson will auto-marshal that into JSON for me. So now to test it out. I'm going to make sure and make sure everything saved and restart the server. Once that's up, I can jump back to Postman, and I can adjust my URL call to simply go to the root or home section. Again, we set that up as a GET verb, so we'll want to make sure we're using GET in the URL call, and we'll go ahead and send that to the server. And you'll notice, we now have an app-version status page for our application. It's returning 1.0 .0. Hopefully this gives you an idea of how easy it is to set up your own custom application properties and use them anywhere in your code that is Spring context aware. Simply inject it and use it. Next, we're going to look at configuration outside of property files using the 100% pure Java code to create configuration.
Demo: Overriding Spring Boot with Java Config
Doing configuration in actual Java code has been around for a while now, but can still be a newer paradigm shift for many Java developers. This concept would be equivalent to metaprogramming and many of the scripted languages today with the exception of DSL, or domain-specific language customizations. I like to lump all of my Java configuration together in a single package, so I'm going to go ahead and create a new package next to the controllers or a sibling to the controllers called config. I can now place all of my Java configuration in here and isolate it and know where it's all at. So first, I'm going to create a new Java class, and I'm going to call it PersistenceConfiguration. This configuration class can be used to customize and create changes or configuration in our persistence tier. Spring needs to know that this is a configuration class, so we need to annotate it as such. Naming it Configuration is not enough, so we'll add an @Configuration annotation and import that. Now here's kind of the strange part, any methods that we define in here can return bean definitions that will get stored in the Spring context. I'm going to show you how to override the data source being provided by the Spring Data JPA starter. We need to first begin with a new method definition on our class, and that will look like this. The return type of this method will be a javax.sql data source. When this method returns the DataSource object, Spring looks for it and tries to see if one already exists in the Spring context. If it does, it will replace its definition with the one that it found. Spring will need to know that this is a Spring bean, so we need to annotate the method as such. We could do that by adding the @Bean annotation and importing that. We can now provide any kind of Java code to build or implement this object however we want. The body of the method is where the configuration actually happens in a Java Config class, so I'm going to add the basic builder to the method by doing this. We'll first create a DataSource builder, and I'll import that. That's following the builder pattern, and it creates a new DataSourceBuilder. Next, I set the URL on there, which is like this. A side note, that URL is the same URL that we had in our application.property file. And then finally, we ask the builder to go ahead and build our DataSource and return it, which since we specified this is a bean, Spring will look for that bean in the Spring context and replace the DataSource definition with what we've implemented here. Now to prove that this is not just smoke and mirrors, I'm going to add a system.out into the method so that we can look for that on application startup so that we know that our bean definition got created. So before the return method, I simply have a System.out .println, which says, My custom datasource bean has been initialized and set. We'll want to look for this in the log startup. So we'll save the file, and let's go ahead and restart our application. So Tomcat has reported that it started on port 5000. That means our application is running. We can now scroll up and look for our message. And here's the message that the app set up in the custom Java configuration class. You might be thinking, why would we want to do this? Well, if you have to do something complex, like maybe you want to log something, maybe you want to send an email when a transaction is committed, or maybe you want to set up two-phase transactions or transactions across, say, a Mongo database and a relational database, you can set up anything you need to do inside of your Java Configuration classes. The more you've worked with these Configuration classes, the more you'll be able to get ideas and see ways that you can utilize this feature. It's certainly worth the time to get transitioned over to this paradigm. We're just about done exploring the world of configuration in Spring Boot, but there is one last concept, and that is creating your own auto configuration.
Creating Your Own Auto-configuration Class
Creating a Spring Boot starter configuration class of your own is not that hard. If you're a company that has lots of projects, you'll probably want to have some core JAR files that provides utility or helper classes that all of your other applications can use. Auto-configuration classes are useful in this scenario. These classes work very similar to the Java configuration class that we just built. You'll need to create a basic class and annotate it with the @Configuration annotation. Next, you can add methods that define beans and functionality that you want to provide for your starter. Last, you'll need to add a declaration in the spring.factories file that you're registering in auto configuration. Spring Boot will inspect JAR files on your class path for this spring.factories file and then bootstrap your auto-configuration files. The spring.factories file typically lives in resources/META-INF. Finally, there are a host of annotations that Spring Boot provides that allow you to specify conditions on your auto configuration. For example, if you're building some auto configuration that is dependent on a Postgres JDBC driver, you could specify that at the class level, it's conditional on the driver being present. If it's there, your auto-configuration will magically wire stuff up, and if it's not there, your configuration will simply do nothing. This is one reason why starters are so powerful and do so much simply by including the dependency on your project in the class path. Clever teams and developers will already have the gears turning in their heads on how they can utilize this concept in their projects and organizations for their common functionality.
Summary
Spring Boot makes configuration very easy to use and work with. There are, however, a lot of options on how you can customize your application. Here's what you should have learned in this section of the course. First, you should know that Spring Boot looks for configuration files on the class path. Your project will typically utilize the src, main, resources folder for this. Spring Boot can read and work with property files and YAML files. There is also an order of precedence of when and their values are configured from external to internal configuration sources. Next, you need to be aware of all the common Spring Boot properties that are provided out of the box by Spring and the various Spring starters. These are your first area of customization when you need to modify something in your application. When it comes to your application, Spring Boot can load in specific files based off of Spring profiles that will override and customize your app per environment. This is the right, or correct, way to handle moving your app from development, to test, to staging, to prod, and so on. Simply provide appropriate environment files configured for each environment profile. Finally, you can start to get fancy with configuration and handle it all in Java. You can even create your own auto-configuration classes and starter JAR files for your apps. And that's it for configuration. The only thing that we have left to do is to figure out the right way to deploy our Spring Boot applications, which we'll be covering in the next section of the course.
Deploying Spring Boot Applications
Introduction
In some ways, deploying applications have gotten easier, and in some ways, deployments have gotten harder. You have a lot of choices you day in should I deploy to a cloud environment, should I run my app on rack servers, should my app be an executable JAR file or a WAR file, and so on? To help you pick a strategy that will work for your project, I'm going to run through these options, as well as discuss the correct way of packaging and bunding a Spring Boot application that includes the JAR option and the WAR file options. Now that we have a robust enough conference API-based application, let's take it to the last and final step, and that's getting it deployed.
Spring Boot Containerless Architecture
If you were a Java developer back in 2005 and you wanted to deploy your application, you'd become very familiar with containers like Tomcat, Glassfish, or Websphere. These were all containers that complied with the JEE specification at that time. And when you deployed a Java application, you created a WAR file and then installed them on these containers. Now with Spring Boot, apps are standalone. Instead of installing your app into a container, Spring has embedded a container inside of the framework. This allows you to run the app in standalone mode now. The default container Spring Boot uses is Tomcat out of the box. You can switch that out to Jetty or Undertow if you prefer a different embedded container. Let's see what it actually takes to switch out an embedded container for our conference application.
Demo: Switching out the Spring Boot Embedded Container
Switching out the default embedded container in a Spring Boot app really isn't that difficult. I'm going to jump into the pom.xml file to begin this. I'm going to scroll down until I find the spring-boot-starter-web dependency. This is the dependency that brings in the Tomcat embedded container. So the first thing that needs to happen is we need to switch out the container by excluding Tomcat from this dependency. And in Maven, you can do that by adding this to the dependency declaration. Simply add an exclusions tag, and inside of there, you can exclude the spring-boot-starter-tomcat artifact. This will no longer load in this dependency when you include the spring-boot-starter-web. Next, we need to bring in the new container dependency. Spring provides starters for Jetty and Undertow. I'm going to use Jetty, so all I need to do is add the following dependency. This dependency will be a sibling of the spring-boot-starter-data-jpa or the spring-boot-starter-web, and it's simply including the spring-boot-starter-jetty. I'm going to go ahead and save the POM file. And since we've modified the POM, IntelliJ is asking if we want to import and sync the changes, which we do, so I'm going to go ahead and click on that. And at that point, we've switched the containers. So all we need to do is start up the application and test it out. So I can go ahead and just start the application up here, clicking on the Play button. Now if we open up the server log and take a look at this after it's started, you'll notice that the container is now stating that it's running with Jetty, and we're started on port 5000, which is the last port we configured. Even though Spring Boot provides configuration and opinionated configuration, it makes it really easy to get out of the way and to customize it for your needs. Most apps, however, will be fine using the default Tomcat container. If, for some reason, you do need to change it, Spring Boot will allow you to do that. Next, let's check out what it takes to get your application packaged so that you can run it as a standalone app outside of the IDE.
Demo: Creating Executable JAR Deployments
There are two ways that you can create a basic standalone JAR file that can be used to run your application. The first is to utilize Maven to create JAR files that you can use to run with the Java command, and here's that'll work. Inside of IntelliJ, we can just execute a Maven command and click on the Maven pop-out in the right-hand corner here and go to this small lowercase m to execute a Maven goal. The Maven goal that we want to run is the mvn package goal. If you inspect the output from running that command, you'll notice that it compiles, runs your test, and then packages your app into a JAR file. Maven will place your artifact or your JAR file inside of this target folder that's part of your application. And if you open this up, you can see that there is a artifact called conference-demo- 0.0 .1 - SNAPSHOT.jar, and that is the JAR file that contains your entire application. To run the application with the Java command, we need to do a couple of things. We first need to make sure that our application is not running inside of the IDE, so I'm going to shut that down, and then I'm going to jump over to a terminal. IntelliJ provides a terminal if you want to just use that. Once the terminal is open, we simply just need to navigate into the target folder, and we can see that we have our JAR file in here. To run the JAR file, you simply need to execute the following command, java -jar, and then supply the JAR file name. When you run this, this will look exactly like the output that you see in the IntelliJ build or run server logs, but here, we're running it from the command line. You can see that it started with the Jetty server on port 5000. So take a moment to think about what has happened here. You can now run your app anywhere that you have Java installed. This could be a server, or the cloud, or just simply, your laptop. I'll go ahead and Ctrl+C this. We'll jump back to the application now. The second way that you can create your JAR file to run your app is to create a standalone executable JAR file. And in order to do this, we need to modify Maven slightly, so I'm going to jump back into the pom.xml file. In the POM file, find the Spring Boot plugin section at the bottom, which is part of the build area, and we're going to add the following to it. We're going to add a configuration tag and specify as executable is true. We'll save the file. IntelliJ is wanting us to import the changes, which we want to do, so we'll click on that. Once that's done synching, we'll want to go ahead and run the Maven package again. So we'll go back to the Maven pop-out, click on the m, and run mvn package. Once that's built successfully, let's jump back to the terminal. I'm going to go ahead and clear out the old output from the previous run so we can start fresh. And this time, you'll notice that we're not going to start the JAR file using the java -jar. It's now a standalone executable JAR file. So on a UNIX or a macOS system, we can execute that by doing the. / and giving it the JAR file name. Now when I run it, you'll see that it's running the JAR file standalone without even having to execute Java. And unfortunately, this particular command only works with UNIX or Linux-based systems. So if you're on Windows, this obviously isn't going to work the same because it's not going to create an EXE file to execute, but you still have the original way of running with a java -jar command on the original JAR file. And that's all it takes to create a Spring Boot deployable app just by running it from the command line. So hopefully you can start to see how powerful this is because you can now run this anywhere that you can run Java, which Java runs just about anywhere. So coming up next, let's look at some of the cloud platforms that we could possibly run our application in.
Common Cloud Supported Platforms
Now that you have a self-contained JAR file that represents your application in standalone mode, you're ready to deploy it and run it on a cloud platform. Common cloud platforms that Spring Boot works with are Cloud Foundry, Heroku, Google Cloud, Amazon Web Services, and Microsoft's Azure. Each of these platforms require setting up different configuration files so the platform knows how to deploy it on its own infrastructure. Even though those details might differ, the standalone JAR artifact you create does not. If you want to give yourself even more flexibility with deployments, you can Dockerize your application. Most all cloud platforms support Docker. You might ask, why would I Dockerize my app if the platform supports deploying a JAR file natively? There are a few reasons. Clustering and portability are just simply two of them. If your app is Dockerize, you can spin up many instances quickly using tools like Docker Compose or Kubernetes. Finally, if you do decide to use a cloud offering, a few things to keep in mind, first, logging can be difficult to track down and use depending on the cloud. It may be a good idea to utilize a centralized logging service. Connecting to your database or other cloud service, like a Redis queue, may require specific handling that can be different than what we covered in the Spring Boot configuration section of this course. Getting all of your services to talk to one another can also be a firewall or a security headache. Since you're in the cloud and things are public, you need to deal with network traffic and communication appropriately. Coming up next, we'll check out how to deploy our application to the Heroku cloud.
Demo: Deploying Spring Boot to the Cloud
I'm going to show you how easy it can be to deploy a Spring Boot app on Heroku. I know there is a lot of cloud options out there, and I chose Heroku for simplicity sake. You could easily spend some time and do the same deployment on AWS, or Digital Ocean, or whatever cloud that you're familiar with. Even if you haven't used Heroku before, many of the steps will be the same elsewhere. The takeaway should be focused on how easy the built Spring Boot JAR files are to work with. This is the main Heroku dashboard after you've created an account. I'm going to go ahead and create a new app by clicking on the New button in the upper-right-hand corner and then clicking Create new app. I'm going to go ahead and give the app a name on Heroku, and we'll call it conference-demo-dan. I'll go ahead and use the United States region and simply click the Create app button. At this point, Heroku is asking to connect to a Git repo so that it can find the app to deploy. I've checked my app into a Git repository, so I'm simply going to click on GitHub, and I can search for my repository by clicking on the Search button and then finding the appropriate repository. I can then click Connect, which will tie it to my cloud Heroku. Heroku has a couple of ways of deploying apps. You can auto deploy on a commit or a check-in. I'm going to go ahead and use the manual way, and select the master branch, and click Deploy Branch button. Heroku then auto detects that it's working with a Java application. And once it's done building, it will say that your app was successfully deployed. You can click the View here, or you can go up into the upper-right-hand corner and click on Open app. Go ahead and try that. And if all went well, you should get the status page that we built that shows the app version number. But check out what happens if we go to our api/v1/sessions endpoint. We get an error rather than a payload, and it says that it's unable to acquire the JDBC connection. If you think about it, this is expected because we haven't set up the Postgres database on Heroku so the app has no database to talk to or work with. If I go back to the Heroku dashboard, I can click on the Resources tab. This is where you can add additional services, and you'll notice that Heroku was smart enough that it already attached a Postgres database. Heroku sets up the database settings in the Settings section of the application. You can look at them here with the Reveal Config Vars. Set up the database URL to an environment variable called DATABASE_URL with the data. If you remember in our application though, we have the DATABASE_URL set to DB_URL as the environment variable. Before we can set up this URL in Heroku, you'll actually have to remember back when we created a custom configuration class on the Java side. If we go into the config folder and open up the PersistenceConfiguration, you'll remember that we built out a DataSource bean, and in here, we actually hard coded the URL. So hard coding things into your app is not the greatest thing. And in this case, it's going to break our deployment on Heroku because localhost with the 5432 port for Postgres is not going to exist. So I'm actually going to go ahead and just comment out this bean and save it, and I'm going to check this back into the Git repository and have Heroku re-pull it. Before I have Heroku re-pull that, you'll notice that we need to modify this to match what we have in our application properties URL, so I'm going to simply add a variable here called DB_URL, and I'm going to copy the database URL into it. Now that the DB_URL is set and the Git repo has been updated to comment out our persistence bean in the Java configuration, I can come back to Deploy and simply deploy the master branch again. Once that's redeployed, I can jump back over to Chrome and test it out. This time, when we hit the sessions URL endpoint, we get another 500 error, but it's about the result set. I can check to see what the error is in my log files on Heroku by coming up to the View logs. Here, our app is telling us that the table sessions does not exist, and again, this makes sense because we have not loaded the data into our production database on Heroku. So I'm going to go ahead and pause the video and load that, and I'll be right back, and we can test it out again with some live data. Okay, I've loaded up the production database using the scripts, like we did when we created our own local database with the create tables and the create data. Let's go ahead and try to access our sessions endpoint again on Heroku, and you'll notice that we now have all of our payloads. Okay, so here's to summarize what's happened. Heroku auto detected our Java Spring Boot app, it ran the Maven package, it installed the Postgres database for us, and it deployed it all to a URL that was accessible. All that we had to do was to load the database and make sure that the app could connect to it properly. If you've ever fussed with getting a Tomcat container set up and then accessible publicly, deployed your app, and get your database set up, you can appreciate how easy some of this cloud stuff is making app development. Now that I just put down the old way of deploying apps, let's take a look at what needs to happen to build a good old WAR file.
What About WAR Deployments?
If you're working with an existing application or an infrastructure, chances are you are already creating a WAR file for deployments to a container. If you've created a Spring Boot app in this environment, you'll need to be able to continue to support deploying to your container, and that's going to require a WAR file. Since our application is a Maven-based application, we need to make some modifications to the pom.xml file to package the app a little differently. Currently, when you build a project, Maven will generate a standalone executable JAR file, and this also contains the embedded container that Spring Boot uses by default, which is Tomcat. The first thing that will need to happen is to flag the embedded container as provided. This will tell Maven to not package Tomcat or whatever embedded container that you're using in the final packaged artifact. Second, we need to tell Maven to package our app as a WAR instead of a JAR file. Once these two changes are done, the Spring Boot Maven plugin will take care of the rest. There is also one small Java coding change you'll have to make, so let's go ahead and modify the conference app to produce a WAR file instead of a JAR file.
Demo: Creating a Spring Boot  WAR Deployment
We'll start by making a couple of changes in the Maven pom.xml file, so I'll go ahead and get that open. The first thing that needs to happen is we need to flag the embedded containers as provided, so I'll need to do a few things here. First, we have a dependency for our spring-boot-starter-jetty. I'm going to go ahead and remove that dependency. And we've also excluded the spring-boot-starter-tomcat in the spring-boot-starter-web dependency, so I'm going to go ahead and remove that as well. Next, I'm going to re-add the spring-boot-starter-tomcat dependency, but I'm going to give it a scope of provided. That means that Maven won't package the Tomcat starter in the build. It expects something externally to provide it. With these changes in place, you won't have an embedded container inside of your application anymore. And the final thing that we need to do is to change the packaging type of the Maven artifact to a WAR. We can do that by adding the following line. I'm going to do that near the top of the file underneath the description area, and that will be packaging tag with a value of war. That now will produce a WAR file rather than a JAR file. Go ahead and save those changes, and IntelliJ is wanting us to import those. We'll do that. Once that's done, we need to make one small Java change, so I'm going to go ahead and close this build section, and I'm going to jump back to src, main, java, jump into my packages, and I want to find the ConferenceDemoApplication class. If you remember, this is our bootstrap class that has the public static void main where everything gets kicked off. The change I want to add in here is I need to have this class extend the following. We want it to extend SpringBootServletInitializer. We'll go ahead and import that class and save the file. When you deploy a WAR file to an external container, it expects a context to be available. It also expects a web.xml file, which defines how the app will get deployed. Since the Spring Boot does not have a web.xml file in it, this class provides that value and information to the external container. Without this, you won't be able to access you app properly via a context when you go to access it. With these changes in place, we can go ahead and open up the Maven pop-out and run mvn package again by going to the little m and running the mvn package command. At this point, you'll notice that we get an error, and I wanted to point this out because this can cause people to run into a lot of issues if you're not familiar with what's happening. So, ultimately, what happens when the test runs is it's looking for everything to be set up correctly. We're currently set up to use our database by using an environment variable. So I'm going to go ahead and close this Run thing here, and I want to go over to the resources, application.properties. In here, the app is expecting this. Well, this is not provided when we run our test. And if you think about it, this environment variable won't be provided when we go out to run our app inside of a Tomcat container, for example. We could end up setting that as a value on there, but just to make things simpler, I'm going to go back into the config, PersistenceConfiguration, and I'm going to reenable the bean that we set up because we've hard coded our URL in here. I'm going to save that file. Now also, keep in mind, you don't want to end up doing this for your production app. You do want to end up using some kind of external configuration source, and a lot of times, the best way to do that in an external container is using JNDI. So you could set these up as JNDI values so you don't have your URL and credentials hard coded into your application. Since we don't have enough time to go into that depth, we'll go ahead and just reenable this and run the mvn package again. This time, the app has built successfully, and if we go look in the target folder, you'll now see that the artifact is a WAR file rather than a JAR file. We still have our old JAR file in there from an earlier build, but we also now have this conference-demo- 0.0 .1 - SNAPSHOT.war file, and this is the file that we'll go ahead and deploy to a Tomcat container. So to deploy my WAR file to a Tomcat instance, I need to go find that WAR file, which is in my target folder, and I'm going to copy this. I'm going to go over to my apache deploy, and you're going to push this into the webapps folder for apache-tomcat. So we'll simply paste that WAR file in here, and then you'll notice that Tomcat will extract that out into an expanded application. By default, Tomcat runs on port 8080, so I'm here at the root of my Tomcat, and I have the Tomcat documentation. To run and access my app, I need to enter the context. Now the context was the name of the folder that I just deployed. That folder name is this big, long thing here, so I'm simply going to copy that and paste that in as my context for my application. So that would be forward-slash and the name of my conference-demo-SNAPSHOT. And when I go to that page now, you'll see that my app is responding to the home or the root endpoint, which is our app-version of 1.0 .0, and the app is now running on a container using the external Tomcat instead of the internal embedded Tomcat. And again, we can go ahead and test out the speakers or the sessions, and I still get my sessions endpoint back. So this is how you can run a Spring Boot application on an external container, and there's only a few changes that you need to make to your app to get that working. Finally, keep in mind that the changes that we've made in this clip will prevent your app from running as a JAR file or a standalone executable JAR file. You can pick one way, or you can pick the other, but you can't have both a JAR and a WAR at the same time. If you want to go back to running your app as a standalone JAR, you'll need to revert the changes that were made in this clip.
Summary
At this point, you should know enough about Spring Boot to take your app from creation all the way to app deployment in a production environment. Here's what we covered in this last section of the course and what some of your takeaways should be. First, Spring Boot uses a containerless architecture. SharePoint utilizes an embedded container under the covers, which supports Tomcat, Jetty, and Undertow servers out of the box. Spring Boot provides a Maven plugin that can then package your application as a standalone executable JAR file that can be run anywhere Java runs. This enables your Spring Boot app to run nicely in cloud environments, and Spring Boot and Spring supports the major cloud offerings. Finally, Spring Boot provides a way to package an app as a WAR file rather than a standalone JAR file. This allows you to deploy the app into an external container if your need arises. And that's it! Thank you for taking the time to learn Spring Boot with me. I really do appreciate the opportunity of helping others pick up new skills and techniques that can help them with their projects and software problems. I encourage you to take the time to continue on the Spring framework learning path to get a deeper understanding of each of the framework pieces that we've worked with in this course.
